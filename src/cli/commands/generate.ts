// Generate command - Generate brand strategy

import type { BrandStrategy, BrandConfiguration, GenerateCommandOptions } from '../../types/index.js';
import { LLMService } from '../../genesis/llm-service.js';
import { FileSystemUtils, logger, FormattingUtils, parseJSON, isBrandStrategyLike } from '../../utils/index.js';
import { HTMLGenerator } from '../../presentation/html-generator.js';
import { createIngestionService } from '../../ingestion/index.js';
import chalk from 'chalk';
import ora from 'ora';

function generateMarkdown(strategy: BrandStrategy, brandName: string): string {
  const sections: string[] = [];

  // Header
  sections.push(`# ${brandName} Brand Strategy`);
  sections.push('');
  sections.push(`**Generated**: ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}`);
  sections.push('');
  sections.push('---');
  sections.push('');

  // Purpose, Mission, Vision
  if (strategy.purpose || strategy.mission || strategy.vision) {
    sections.push('## Brand Foundation');
    sections.push('');

    if (strategy.purpose) {
      sections.push('### Purpose');
      sections.push(strategy.purpose);
      sections.push('');
    }

    if (strategy.mission) {
      sections.push('### Mission');
      sections.push(strategy.mission);
      sections.push('');
    }

    if (strategy.vision) {
      sections.push('### Vision');
      sections.push(strategy.vision);
      sections.push('');
    }
  }

  // Values
  if (strategy.values && strategy.values.length > 0) {
    sections.push('## Core Values');
    sections.push('');
    strategy.values.forEach(value => {
      sections.push(`- ${value}`);
    });
    sections.push('');
  }

  // Positioning
  if (strategy.positioning) {
    sections.push('## Brand Positioning');
    sections.push('');
    sections.push(strategy.positioning);
    sections.push('');
  }

  // Personality
  if (strategy.personality && strategy.personality.length > 0) {
    sections.push('## Brand Personality');
    sections.push('');
    strategy.personality.forEach(trait => {
      sections.push(`- ${trait}`);
    });
    sections.push('');
  }

  // Voice & Tone
  if (strategy.voiceAndTone) {
    sections.push('## Voice & Tone');
    sections.push('');

    if (strategy.voiceAndTone.voice) {
      sections.push('### Brand Voice');
      sections.push(strategy.voiceAndTone.voice);
      sections.push('');
    }

    if (strategy.voiceAndTone.toneAttributes && strategy.voiceAndTone.toneAttributes.length > 0) {
      sections.push('### Tone Attributes');
      sections.push('');
      strategy.voiceAndTone.toneAttributes.forEach(attr => {
        sections.push(`- ${attr}`);
      });
      sections.push('');
    }
  }

  // Key Messages
  if (strategy.keyMessages && strategy.keyMessages.length > 0) {
    sections.push('## Key Messages');
    sections.push('');
    strategy.keyMessages.forEach((message, index) => {
      sections.push(`${index + 1}. ${message}`);
    });
    sections.push('');
  }

  // Differentiators
  if (strategy.differentiators && strategy.differentiators.length > 0) {
    sections.push('## Competitive Differentiation');
    sections.push('');
    strategy.differentiators.forEach(diff => {
      sections.push(`- ${diff}`);
    });
    sections.push('');
  }

  sections.push('---');
  sections.push('');
  sections.push('*Generated by Brand Builder Pro - AI-Powered Brand Intelligence Operating System*');

  return sections.join('\n');
}

function extractBrandStrategy(rawResponse: string, brand: string): {
  strategy: BrandStrategy;
  parseMethod?: string;
} {
  const parsed = parseJSON<Record<string, unknown>>(rawResponse);

  if (!parsed.success || !parsed.data) {
    throw new Error(
      'Generated strategy could not be parsed as valid JSON. ' +
      'Update the prompt or retry to ensure the response is structured JSON.'
    );
  }

  const payload = parsed.data;
  const candidate = isBrandStrategyLike(payload)
    ? payload
    : (payload?.['brandStrategy'] as unknown);

  if (!isBrandStrategyLike(candidate)) {
    throw new Error(
      'Generated strategy is missing a `brandStrategy` object with core fields (purpose, mission, positioning, etc.).'
    );
  }

  const strategy = candidate;

  if (!strategy.keyMessages || strategy.keyMessages.length === 0) {
    logger.warn('Generated strategy contains no key messages', { brand });
  }

  return { strategy, parseMethod: parsed.method };
}

export async function generateCommand(options: GenerateCommandOptions): Promise<void> {
  const spinner = ora('Generating brand strategy...').start();

  try {
    const { brand, mode, output, format, useContext = false } = options;

    if (!brand) {
      throw new Error('Brand name is required. Use --brand flag.');
    }

    logger.info('Generate command', { brand, mode, useContext });

    // Load brand config
    const workspacePath = FileSystemUtils.getBrandWorkspacePath(brand);
    const configPath = `${workspacePath}/config.json`;

    if (!(await FileSystemUtils.fileExists(configPath))) {
      throw new Error(`Brand workspace not found. Run: brandos init --brand "${brand}"`);
    }

    const config = await FileSystemUtils.readJSON<BrandConfiguration>(configPath);

    // Build base context
    let contextText = `Brand Configuration:\n${JSON.stringify(config, null, 2)}\n\nMode: ${mode}`;

    // Retrieve additional context from ORACLE if requested
    if (useContext) {
      spinner.text = 'Retrieving brand context from ORACLE...';

      try {
        const ingestion = createIngestionService();
        const oracleContext = await ingestion.searchContext(
          brand,
          `What is ${brand}'s purpose, mission, values, positioning, and key differentiators?`,
          2000 // Max tokens for context
        );

        if (oracleContext && oracleContext.length > 0) {
          contextText += `\n\n**Additional Brand Context from Documents:**\n${oracleContext}`;
          logger.info('Retrieved context from ORACLE', {
            brand,
            contextLength: oracleContext.length,
          });
        } else {
          logger.warn('No context found in ORACLE', { brand });
          spinner.text += ' (no indexed documents found)';
        }
      } catch (error) {
        logger.warn('ORACLE context retrieval failed', {
          error: (error as Error).message,
        });
        // Continue without ORACLE context
      }
    }

    contextText += `\n\nGenerate a comprehensive, specific strategy for ${brand}.`;

    // Generate strategy using LLM with prompt registry
    const llm = new LLMService();

    spinner.text = useContext
      ? `Generating ${mode} strategy with brand context...`
      : `Generating ${mode} strategy using prompt registry...`;

    // Use the brand-strategy-gen prompt from registry
    const response = await llm.promptFromRegistry(
      'brand-strategy-gen',
      {
        brandName: brand,
        industry: config.industry || config.category || 'general',
        context: contextText
      }
    );

    const strategyText = response.content;

    logger.info('Strategy generated with prompt registry', {
      promptId: 'brand-strategy-gen',
      runId: response.metadata.runId,
      model: response.metadata.model
    });
    const { strategy, parseMethod } = extractBrandStrategy(strategyText, brand);

    const outputPayload = {
      brandName: brand,
      generatedAt: new Date().toISOString(),
      mode,
      strategy,
      rawContent: strategyText,
      metadata: {
        parseMethod: parseMethod ?? 'unknown',
      },
    };

    // Save strategy based on format
    const basePath = output || `outputs/strategies/${FormattingUtils.sanitizeFilename(brand)}-strategy`;
    const outputs: string[] = [];

    // Always save JSON
    if (format === 'json' || format === 'both') {
      const jsonPath = output || `${basePath}.json`;
      await FileSystemUtils.writeJSON(jsonPath, outputPayload);
      outputs.push(jsonPath);
    }

    // Generate HTML if requested
    if (format === 'html' || format === 'both') {
      const htmlGenerator = new HTMLGenerator();
      const htmlDoc = await htmlGenerator.generateFromStrategy(
        strategy,
        brand,
        {
          title: `${brand} Brand Strategy`,
          theme: 'professional',
          includeTOC: true,
          includeMetadata: true,
        }
      );

      const htmlPath = `${basePath}.html`;
      await FileSystemUtils.writeFile(htmlPath, htmlDoc.html);
      outputs.push(htmlPath);
    }

    // Generate Markdown if requested
    if (format === 'markdown' || format === 'both') {
      const markdownContent = generateMarkdown(strategy, brand);
      const mdPath = `${basePath}.md`;
      await FileSystemUtils.writeFile(mdPath, markdownContent);
      outputs.push(mdPath);
    }

    spinner.succeed(chalk.green('Strategy generated successfully!'));

    console.log('\n' + chalk.bold('Strategy Generated:'));
    console.log(chalk.cyan(`  Brand: ${brand}`));
    console.log(chalk.cyan(`  Mode: ${mode}`));
    console.log(chalk.cyan(`  Format: ${format}`));
    outputs.forEach(path => {
      console.log(chalk.cyan(`  Output: ${path}`));
    });

  } catch (error) {
    spinner.fail(chalk.red('Failed to generate strategy'));
    logger.error('Generate command failed', error);
    console.error(chalk.red(`Error: ${(error as Error).message}`));
    process.exit(1);
  }
}
